{
  "name": "ABC JS",
  "tagline": "javascript functional programming library",
  "body": "# abcjs\r\n_abcjs는 함수형 자바스크립트(functional javascript) 라이브러리입니다._\r\n\r\n## 특징\r\n  - Web browser와 NodeJS에서 사용할 수 있습니다.\r\n  - Promise, jQuery Deferred Object, Future 등의 모나드식 해법 보다 간결하고 편리한 비동기 제어를 지원합니다.\r\n  - 비동기 함수일지라도 동기 함수를 작성하듯이 논리 구조를 만들 수 있습니다.\r\n  - 비동기 제어 기능을 더한 `each`, `map`, `reduce`, `filter`, `reject`, `find`, `findIndex`, `some`, `every`, `uniq` 함수가 있습니다.\r\n  - Jade와 비슷한 HTML Template 함수가 있습니다. 함수 사용과 비동기 함수를 지원합니다.\r\n  - sql 등을 작성하기 편한 함수가 있습니다.\r\n  - 다른 자바스크립트 라이브러리에 대한 의존성이 없는 작은 라이브러리입니다.\r\n  - _Respect Underscorejs!_\r\n\r\n\r\n## 시작하기\r\n__abcjs와 함께 함수형 프로그래밍을 즐겨보세요.__\r\n\r\n## 목차\r\n - [A (apply)](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#01-a)\r\n - [B (bind)](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#02-b)\r\n - [C (call)](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#03-c)\r\n - [Pipeline with ABC](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#04-pipeline-with-abc)\r\n - [Async (callback)](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#05-asynccallback)\r\n - [Async-2 (Promise)](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#06-async-2promise)\r\n - [each, map, find, ...](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#07-eachmapfind)\r\n - [HTML Template](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#08-html-template)\r\n - [IF ELSEIF ELSE](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#09-if-elseif-else)\r\n - [B.all B.div](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#10-ball-bdiv)\r\n - [this](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#11-this)\r\n - [ETC](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#12-etc)\r\n - [throw, ERR, CATCH](https://github.com/marpple/abc-functional-javascript/blob/master/README.md#13-throw-err-catch)\r\n\r\n### 01. [A](https://github.com/marpple/abc-functional-javascript/blob/master/README.md/blob/master/example/01.%20A.html)\r\n\r\n`A`는 `apply`와 비슷합니다.\r\n\r\n```javascript\r\nfunction add(a, b) {\r\n    return a + b;\r\n}\r\n\r\nvar r1 = A([20, 2], add); // add.apply(undefined, [20, 2]);\r\nconsole.log(r1);\r\n// 22\r\n```\r\n\r\n\r\n\r\n왼쪽에서 오른쪽, 위에서 아래로 읽는게 편안합니다. 그래서 `A`는 인자와 함수사용에 대한 방향을 바꾸었습니다.\r\n```javascript\r\nfunction minus(a, b) {\r\n    return a - b;\r\n}\r\n\r\nvar r2 = A([20, 5], function() {\r\n    return A(arguments, minus);\r\n});\r\nconsole.log(r2);\r\n// 15\r\n```\r\n배열이나 arguments객체를 사용하면 됩니다.\r\n\r\n\r\n### 02. [B](https://github.com/marpple/abc-functional-javascript/blob/master/example/02.%20B.html)\r\n`B`는 `this`를 제외한 `bind`라고 생각하면 쉽습니다.\r\n혹은 underscore의 `_.partial`과 유사합니다.\r\n```javascript\r\nfunction minus(a, b) {\r\n    return a - b;\r\n}\r\n\r\nvar f1 = B(10, minus);\r\nvar r1 = f1(20);\r\nconsole.log(r1);\r\n// -10\r\n```\r\n\r\n\r\n`B`를 `X`와 함께 사용해보세요.\r\n`X`를 통해 이후 실행시에 받게될 인자의 자리를 지정해둘 수 있습니다.\r\n```javascript\r\nvar f2 = B(X, 10, minus);\r\nvar r2 = f2(20);\r\nconsole.log(r2);\r\n// 10\r\n\r\nfunction minus2(a, b, c, d) {\r\n    return a - b - c - d;\r\n}\r\n\r\nvar f3 = B(4, X, X, 1, minus2);\r\nvar r3 = f3(3, 2);\r\nconsole.log(r3);\r\n// -2\r\n```\r\n\r\n\r\n\r\n### 03. [C](https://github.com/marpple/abc-functional-javascript/blob/master/example/03.%20C.html)\r\n`C`는 `this`를 제외한 `call`이라고 생각하면 쉽습니다.\r\n```javascript\r\nfunction minus(a, b) {\r\n    return a - b;\r\n}\r\n\r\nvar r1 = C(10, 20, minus);\r\nconsole.log(r1);\r\n// -10\r\n\r\nvar r2 = C(20, 10, minus);\r\nconsole.log(r2);\r\n// 10\r\n```\r\n\r\n\r\n\r\n### 04. [Pipeline with ABC](https://github.com/marpple/abc-functional-javascript/blob/master/example/04.%20Pipeline%20with%20ABC.html)\r\nabcjs는 underscore의 `_.compose`나 jQuery의 chain과 유사한 코드 패턴을 지원합니다.\r\n객체지향적인 체인방식은 연속적으로 값을 변경해나갈 수 있지만 자신이 가진 값을 바꾸는 방법이기 때문에 사용은 쉽지만 구현이 어렵습니다.\r\n또한 자신이 가진 메소드와 자신의 값만을 사용하기 때문에 제약이 있습니다. 파이프라인과 같은 연속적인 함수 실행 방식은 체인방식보다 유연하고 순수 함수들을 만들 수 있어 좋습니다.\r\n\r\nabcjs에서는 별도의 파이프라인 함수를 만들지 않고 기본 함수 실행 함수인 ABC에서 파이프라인 패턴을 바로 사용할수 있도록 했습니다.\r\n또한 `_.compose`와 달리 읽기 쉬운 방향으로 순서를 바꿨습니다. 쉽습니다. 마지막 인자 자리에 함수 대신 배열로 함수들을 나열하기만 하면 됩니다.\r\n```javascript\r\nfunction sum(a, b) {\r\n    return a + b;\r\n}\r\n\r\nfunction square(a) {\r\n    return a * a;\r\n}\r\n\r\nvar r1 = C(1, 2, [\r\n    sum,\r\n    square,\r\n    square,\r\n    function(a) {\r\n        console.log(a); // 81\r\n        return a - 20;\r\n    }]);\r\n\r\nconsole.log(r1);\r\n// 61\r\n```\r\n\r\n\r\n`1, 2` 인자는 `sum`에게 `sum`의 결과는 `square`에게 그리고 그 함수의 결과는 계속 다음 함수의 인자로 넘어갑니다. 그리고 마지막 함수의 return 값은 `C`의 실행 결과가 됩니다.\r\n\r\n`A`를 이용하면 배열과 arguments객체로 파이프라인 패턴을 사용할 수 있습니다.\r\n```javascript\r\nA([1, 2], [\r\n    sum,\r\n    square,\r\n    square,\r\n    function(a) {\r\n        return a - 20;\r\n    },\r\n    function(r1) {\r\n        console.log(r1);\r\n        // 61\r\n    }]);\r\n```\r\n\r\n\r\n`B` 함수를 이용하면 작은 함수를 모아 큰 함수를 만들 수 있습니다. 혹은 큰 함수를 작은 단위로 쪼갤 수 있습니다. 작은 함수가 많아지면 코드 재활용률을 높일 수 있습니다.\r\n```javascript\r\nvar f1 = B([\r\n    sum,\r\n    square,\r\n    square,\r\n    function(a) {\r\n        console.log(a); // 81\r\n        return a - 20;\r\n    }]);\r\n\r\nvar r3 = f1(1, 2);\r\nconsole.log(r3);\r\n// 61\r\n```\r\n\r\n\r\n함수 조합에서도 `X`와 함께 사용하여 인자를 미리 적용 해둘 수 있습니다.\r\n```javascript\r\nfunction minus(a, b) {\r\n    return a - b;\r\n}\r\n\r\nvar f2 = B(X, 10, [\r\n    f1,\r\n    B(X, 11, minus)\r\n]);\r\n\r\nvar r4 = f2(-7);\r\nconsole.log(r4);\r\n// 50\r\n```\r\n\r\n\r\nchain 패턴이나 `_.compose`, `Promise` 등의 일종의 파이프라인 혹은 모나드 등에서 아쉬운점은 함수 모음의 첫번째 함수를 제외하고는 인자를 하나만 받을 수 있다는 점 입니다.\r\n\r\n`B(X, 11, minus)` 를 통해 두개의 인자가 사용되도록 했지만 여전히 사실은 위에서 부터 내려오는 인자는 하나입니다.\r\n\r\n인자를 하나만 받는 함수만 조립할 수 있다면 실용성이 떨어지고 인자가 두개 이상 필요한 함수를 사용하기 위해선 항상 wrapper 함수가 있어야합니다.\r\n이를 위해 `MR`이 있습니다. `MR`을 이용하면 다음 함수가 여러개의 결과를 인자로 받을 수 있습니다.\r\n`MR` 사용은 아래와 같은 두가지 사용법이 있습니다.\r\n```javascript\r\nC(3, 2, [\r\n    function(a, b) {\r\n        return MR(a + b, a - b, a * b); // multiple results\r\n    },\r\n    function(a, b, c) {\r\n        console.log(a, b, c);\r\n        return MR(a, c); // multiple results\r\n    },\r\n    function(a, c) {\r\n        console.log(a, c);\r\n        return arguments;\r\n    },\r\n    C.toMR, // arguments to multiple results\r\n    function(a, c) {\r\n        console.log(a, c); // 5, 6\r\n    }]);\r\n```\r\n\r\n\r\n`B`를 통해 함수를 정의하면 ABC를 이용하지 않고도 `MR()`을 동작 시킬 수 있습니다.\r\n```javascript\r\nvar minus = B(function(a, b) {\r\n    console.log(a, b); // 20, 10\r\n    return a - b;\r\n});\r\n\r\nvar r5 = minus(10, 20);\r\nconsole.log(r5); // -10\r\n\r\n/* swap 함수의 multiple results를 바로 minus에게 넘김 */\r\nvar swap = function(a, b) {\r\n    return MR(b, a);\r\n};\r\nvar r6 = minus(swap(10, 20));\r\nconsole.log(r6);\r\n// 10\r\n```\r\n`MR`은 Go언어의 Multiple Results와 비슷합니다.\r\n[GO Lang - Multiple Results](https://tour.golang.org/basics/6)\r\n\r\n\r\n함수 조립의 즐거움을 맛보세요.\r\n```javascript\r\nvar difference = B([\r\n    function(a, b) {\r\n        return MR(Math.max(a, b), Math.min(a, b));\r\n    },\r\n    minus\r\n]);\r\n\r\nvar r7 = difference(10, 20);\r\nconsole.log(r7);\r\n// 10\r\n\r\nvar r8 = difference(30, 10);\r\nconsole.log(r8);\r\n// 20\r\n```\r\n\r\n\r\n\r\nabcjs의 다른 함수를 활용하면  `difference`를 아래와 같이 구현할 수도 있습니다.\r\n```javascript\r\nvar difference2 = B([\r\n    C.args, // function() { return arguments },\r\n    _.toArray,\r\n    B.M('sort'), // function(a) { return a.sort(); },\r\n    B.M('reverse'),  // function(a) { return a.reverse(); },\r\n    C.toMR, // array to multiple results\r\n    minus]);\r\n\r\nvar r9 = difference2(10, 20);\r\nconsole.log(r9);\r\n// 10\r\n\r\nvar r10 = difference2(30, 10);\r\nconsole.log(r10);\r\n// 20\r\n\r\nvar difference3 = B([minus, Math.abs]);\r\n\r\nvar r11 = difference3(10, 20);\r\nconsole.log(r11);\r\n// 10\r\n\r\nvar r12 = difference3(30, 10);\r\nconsole.log(r12);\r\n// 20\r\n```\r\n\r\n\r\n\r\n### 05. [Async(callback)](https://github.com/marpple/abc-functional-javascript/blob/master/example/05.%20Async%20(callback).html)\r\nabcjs에서는 비동기 제어와 관련된 다양한 기능을 제공합니다.\r\n파이프라인에서 사용할 콜백 패턴의 함수를 `CB` 함수로 한번 넘겨 두기만 하면 됩니다.\r\n`CB`가 감싸졌던 `f1`이라는 함수를 파이프라인에 넣어두면 `C`함수 안에서 `f1`에게 필요한 callback 함수를 생성하여 마지막 인자로 넣어줍니다.\r\n생성된 callback 함수로 값을 꺼낸 후 파이프라인의 다음 함수에게 결과를 전달합니다.\r\n`CB`로 감싼 후 callback 함수 인자의 자리만 제외하고 실행하거나 `CB(익명함수)`를 통해 `C`에게 받은 callback 함수를 사용하여 결과를 다음 함수로 전달할 수 있습니다.\r\nPromise와 달리 여러개의 인자를 다음 함수로 주고 있던 함수이더라도 여러개의 인자로 받을 수 있습니다.\r\n이런 콜백 함수와 사용할때 유용합니다. `function(err, data) { ... }`\r\n\r\n```javascript\r\nfunction delay(func) {\r\n    setTimeout(function() {\r\n        func();\r\n    }, 1000);\r\n}\r\n\r\nfunction sum(a, b, cb) {\r\n    delay(function() {\r\n        cb(a + b);\r\n    });\r\n}\r\n\r\nfunction minus(a, b, cb) {\r\n    delay(function() {\r\n        cb(a - b);\r\n    });\r\n}\r\n\r\nfunction square(a, cb) {\r\n    delay(function() {\r\n        cb(a * a);\r\n    });\r\n}\r\n\r\nsum(10, 20, function (r) {\r\n    console.log(r); // 30\r\n});\r\n\r\nminus(10, 7, function(r) {\r\n    console.log(r); // 3\r\n});\r\n\r\nsum(5, 7, function(r) {\r\n    minus(r, 5, function(r) {\r\n        square(r, function(r) {\r\n            console.log(r); // 49\r\n        });\r\n    });\r\n});\r\n```\r\n\r\n`CB`를 감싸두기만 하면 됩니다. 파이프라인이 넘겨준 `CB` 함수를 이용하여 값을 넘기면 다음 함수로 전달됩니다.\r\n```javascript\r\nCB(sum, minus, square);\r\n\r\nC(5, 10, [\r\n    sum,\r\n    CB(function(r, cb) {\r\n        minus(r, 5, cb);\r\n    }),\r\n    square,\r\n    function(r) {\r\n        console.log(r); // 100\r\n    }\r\n]);\r\n```\r\n\r\n`B`를 활용하여 좀더 간략하게 만들 수 있습니다.\r\n```javascript\r\nC(5, 9, [\r\n    sum,\r\n    B(X, 5, minus),\r\n    square,\r\n    function(r) {\r\n        console.log(r); // 81\r\n    }\r\n]);\r\n```\r\n\r\n\r\n```javascript\r\n.then(function() {\r\n  return new Promise(function(rs) {\r\n      sum(5, 10, rs)\r\n  });\r\n}).then(function() {\r\n  return new Promise(function(rs) {\r\n      minus(5, 10, rs)\r\n  });\r\n});\r\n```\r\n\r\n이 방법은 일반 콜백함수를 Promise로 제어하는 것보다 간단합니다. 또한 새로운 함수를 만들지 않으며 `CB`를 감싼 뒤라도 콜백 패턴의 함수를 원래 사용하던대로 사용할 수도 있습니다.\r\n유사한 개념이지만 새로운 함수를 뱉는 `Promise.promisify` 보다 단순하고 새로운 개념을 알 필요가 없습니다.\r\n`.then()`과 달리 multiple results도 가능합니다.\r\n```javascript\r\nC(5, 9, [\r\n    sum,\r\n    CB(function(a, cb) {\r\n        delay(function() {\r\n            cb(a, 10); // auto multiple results\r\n        });\r\n    }),\r\n    minus,\r\n    function(r) {\r\n        console.log(r); // 4\r\n    }\r\n]);\r\n```\r\n\r\n\r\n```javascript\r\nvar $ = {};\r\n\r\n$.get = function(url, cb) {\r\n    delay(function() {\r\n        cb({\r\n            a: 5,\r\n            b: 3\r\n        });\r\n    });\r\n};\r\n\r\n$.post = function(url, data, cb) {\r\n    delay(function() {\r\n        cb(_.extend(data, { created_at: new Date() }));\r\n    });\r\n};\r\n\r\n$.put = function(url, data, cb) {\r\n    delay(function() {\r\n        cb(_.extend(data, { updated_at: new Date() }));\r\n    });\r\n};\r\n```\r\n`$.get`, `$.post` 등과 유사한 위와 같은 함수가 있다고 가정할때 아래와 같이 활용할 수 있습니다.\r\n```javascript\r\nC([\r\n    CB(function(cb) {\r\n        $.get(\"/get_data\", cb);\r\n    },\r\n    function(data, cb) {\r\n        console.log(_.clone(data)); // {a: 5, b: 3}\r\n        $.post(\"/post_data\", _.extend(data, { c: 10 }), cb);\r\n    },\r\n    function(data, cb) {\r\n        console.log(_.clone(data)); // {a: 5, b: 3, c: 10, created_at: Tue Sep 13 2016 04:01:19 GMT+0900 (KST)}\r\n        $.put(\"/put_data\", _.extend(data, { c: 5 }), cb);\r\n    }),\r\n    function(r) {\r\n        console.log(r);\r\n        // {a: 5, b: 3, c: 5, created_at: Tue Sep 13 2016 04:03:58 GMT+0900 (KST), updated_at: Tue Sep 13 2016 04:03:59 GMT+0900 (KST)}\r\n    }\r\n]);\r\n```\r\n\r\n`B`를 활용하면 더욱 깔끔하게 만들 수 있습니다.\r\n```javascript\r\nCB($.get, $.post, $.put);\r\n\r\nC([\r\n    B(\"/get_data\", $.get),\r\n    B({ c: 20 }, _.extend),\r\n    B(\"/post_data\", $.post),\r\n    B({ c: 30 }, _.extend),\r\n    B(\"/put_data\", $.put),\r\n    function(r) {\r\n        console.log(r);\r\n        // {c: 20, a: 5, b: 3, created_at: Tue Sep 13 2016 04:01:19 GMT+0900 (KST), updated_at: Tue Sep 13 2016 04:01:20 GMT+0900 (KST)}\r\n    }\r\n]);\r\n```\r\n\r\n`J`와 `MR`을 활용하면 다음과 같이 사용할 수 있습니다.\r\n```javascript\r\nfunction J(v) {\r\n return function() {\r\n     return v;\r\n }\r\n}\r\n```\r\n\r\n```javascript\r\nC([\r\n    J(MR(\"/post_data\", { aka: 'Cojamm' })),\r\n    $.post,\r\n    function(r) {\r\n        console.log(r); // {aka: \"Cojamm\", created_at: Tue Sep 13 2016 04:01:18 GMT+0900 (KST)}\r\n    }\r\n]);\r\n```\r\n_*참고 - 실제 jQuery의 `$.get` 함수등은 `{ then: func.. }` 를 리턴하기 때문에 `CB`로 감싸는 방식으로 구현할 필요 없습니다._\r\n\r\n```javascript\r\n/* B를 감싸서 함수를 만들어두면 아래와 같이도 사용할 수 있습니다. 비동기 함수를 아래와 같이도 사용할 수 있습니다. */\r\nCB(sum, minus, square);\r\nfunction sum(a, b, cb) {\r\n    delay(function() {\r\n        cb(a + b);\r\n    });\r\n}\r\nfunction minus(a, b, cb) {\r\n    delay(function() {\r\n        cb(a - b);\r\n    });\r\n}\r\nfunction square(a, cb) {\r\n    delay(function() {\r\n        cb(a * a);\r\n    });\r\n}\r\nvar sq = B(square);\r\nvar m5 = B(X, 5, minus);\r\nvar s = B(sum);\r\nvar log = B(function() {\r\n    console.log.apply(console, arguments);\r\n});\r\nlog(sq(m5(s(10, 10))));\r\nconsole.log('216 line');\r\n```\r\n\r\n### 06. [Async-2(Promise)](https://github.com/marpple/abc-functional-javascript/blob/master/example/06.%20Async-2%20(Promise).html)\r\nabcjs는 Promise가 필요 없지만 `.then`을 리턴하는 함수의 비동기 제어를 지원합니다.\r\n```javascript\r\nfunction delay() {\r\n    return new Promise(function(rs) {\r\n        setTimeout(function() {\r\n            rs();\r\n        }, 1000);\r\n    })\r\n}\r\n\r\nfunction sum(a, b) {\r\n    return delay().then(function() {\r\n        return a + b;\r\n    });\r\n}\r\n\r\nfunction minus(a, b) {\r\n    return delay().then(function() {\r\n        return a - b;\r\n    });\r\n}\r\n\r\nfunction square(a) {\r\n    return delay().then(function() {\r\n        return a * a;\r\n    });\r\n}\r\n\r\n// Promise\r\nsum(2, 4)\r\n    .then(function(r) {\r\n        return minus(r, 4);\r\n    }).then(function(r) {\r\n        return square(r);\r\n    }).then(function(r) {\r\n        console.log(r); // 4\r\n    });\r\n\r\n// ABC\r\nC(3, 6, [\r\n    sum,\r\n    function(r) {\r\n        return minus(r, 5);\r\n    },\r\n    square,\r\n    function(r) {\r\n        console.log(r); // 16\r\n    }]);\r\n```\r\n\r\n\r\n아래와 같이 마지막 결과를 `then`으로 받을 수 있어 Promise와 함께 사용이 가능합니다.\r\n```javascript\r\nC(5, 5, [\r\n    sum,\r\n    square\r\n]).then(function(r) {\r\n    console.log(r); // 100\r\n});\r\n\r\nsum(2, 4)\r\n    .then(function(r) {\r\n        return C(r, 2, [\r\n            sum,\r\n            square\r\n        ]);\r\n    }).then(function(r) {\r\n        console.log(r); // 64\r\n    });\r\n\r\n// B를 사용하면 더욱 간단하게 만들 수 있습니다.\r\nsum(2, 4)\r\n    .then(B(X, 2, [\r\n        sum,\r\n        square\r\n    ])).then(function(r) {\r\n        console.log(r); // 64\r\n    });\r\n\r\n// CB와 함께 사용 가능합니다.\r\nC(5, 5, [\r\n    sum,\r\n    square,\r\n    CB(function(r, cb) {\r\n        cb(r / 2)\r\n    })\r\n]).then(function(r) {\r\n    console.log(r); // 50\r\n});\r\n```\r\n만일 es6 Promise나 Promise Library가 있다면 `C()`는 Promise 객체를 리턴합니다.\r\n그렇지 않다면 `C()`의 리턴 값이 `{}.then()`의 형태를 띄지만 Promise 객체는 아닙니다.\r\n`function has_promise() { (window || global).Promise.prototype.then; }`\r\n`has_promise() ? new Promise(function(rs) { resolve = rs; }) : { then: function(rs) { resolve = rs; } })`\r\n\r\n\r\n\r\n### 07. [each...map...find...](https://github.com/marpple/abc-functional-javascript/blob/master/example/07.%20each...map...find....html)\r\nunderscorejs의 `each`, `map`, `find` 등의 함수보다 편의성을 높였습니다.\r\n  1. this는 사용하지 않으며 대신 iteratee 함수에게 인자를 여러개를 넘길 수 있습니다.\r\n    - ex) [1, 2, 3], arg1, arg2, arg3 => value, key, list, arg1, arg2, arg3 ...\r\n  2. 비동기 제어가 됩니다.\r\n  3. iteratee나 predicate 함수를 파이프라인으로 만들 수 있습니다.\r\n  4. 즉시 실행인 `C.map`과 부분 실행 컨셉의 `B.map`이 있어 파이프라인에서 편하게 사용할 수 있습니다.\r\n\r\n```javascript\r\nfunction delay(func) {\r\n    setTimeout(function() {\r\n        func();\r\n    }, 1000);\r\n}\r\n\r\nfunction sum(a, b) {\r\n    return a + b;\r\n}\r\n\r\nfunction square(a) {\r\n    return a * a;\r\n}\r\n\r\nC.each([1, 2, 3], function(v) {\r\n    console.log(v);\r\n});\r\n// 1\r\n// 2\r\n// 3\r\n\r\nvar r1 = C.map([1, 2, 3], square);\r\nconsole.log(r1); // [1, 4, 9]\r\n\r\n/* iteratee 함수를 파이프라인으로 만들 수 있습니다. */\r\nvar r2 = C.map({ a: 1, b: 2, c: 3 }, [I, square]);\r\nconsole.log(r2); // [1, 4, 9]\r\n\r\nvar r3 = C.map([1, 2, 3], 5, function(v, i, l, a) { //val, idx, list, 5\r\n    return sum(v, a);\r\n});\r\nconsole.log(r3); // [6, 7, 8]\r\n\r\n/* B.args는 들어온 인자중 원하는 번째의 인자를 선택하여 Multiple Results로 만듭니다. */\r\nvar r4 = C.map([1, 2, 3], 5, [B.args(0, 3), sum]);\r\nconsole.log(r4); // [6, 7, 8]\r\n\r\nvar r6 =\r\n    C({ a: 1, b: 2, c: 3 }, [\r\n        B.map(I), // [1, 2, 3] // function I(v) { return v; }\r\n        B.map(square), // [1, 4, 9]\r\n        function(v) { return MR(v, 0); },\r\n        B.reduce(function(memo, v) {\r\n            return memo + v;\r\n        })]);\r\nconsole.log(r6); // 14\r\n\r\nvar minus = function(a, b) {\r\n    return a - b;\r\n};\r\n\r\nC({ a: 1, b: 2, c: 3 }, [\r\n    B.map(I), // [1, 2, 3]\r\n    B.map(square), // [1, 4, 9]\r\n    function(v) { return MR(v, 0); },\r\n    B.reduce([B.args(0, 1), minus]), // 동기\r\n    function(r7) {\r\n        console.log(r7); // -14\r\n    }]);\r\n\r\nvar minus2 = CB(function(a, b, cb) {\r\n    delay(function() {\r\n        cb(a - b);\r\n    });\r\n});\r\n```\r\n\r\n\r\n비동기 함수가 있어도 코딩 패턴을 바꾸지 않고 편하게 코딩할 수 있습니다.\r\n```javascript\r\nC({ a: 1, b: 2, c: 3 }, [\r\n    B.map(I), // [1, 2, 3]\r\n    B.map(square), // [1, 4, 9]\r\n    function(v) { return MR(v, 0); },\r\n    B.reduce([B.args(0, 1), minus2]), // 비동기\r\n    function(r7) {\r\n        console.log(r7); // -14\r\n    }]);\r\n\r\nvar users = [\r\n    { id: 1, age: 20, activated: true  },\r\n    { id: 2, age: 20, activated: false },\r\n    { id: 3, age: 31, activated: false },\r\n    { id: 4, age: 32, activated: true },\r\n    { id: 5, age: 17, activated: true },\r\n    { id: 6, age: 32, activated: true }\r\n];\r\n\r\nC(users, [\r\n    B.filter(B.V('activated')),\r\n    B.reject(function(user) {\r\n        return user.age > 30;\r\n    }),\r\n    B.map(B.V('age')),\r\n    function(r8) {\r\n        console.log(r8); // [20, 17]\r\n    }]);\r\n\r\nC(users, [\r\n    B.uniq('age'),\r\n    B.map(B.V('id')),\r\n    function(r9) {\r\n        console.log(r9); // [1, 3, 4, 5]\r\n    }]);\r\n\r\nC(users, [\r\n    G[\":reject :age > 30\"] = B.reject(function(user) {\r\n        return user.age > 30;\r\n    }),\r\n    B.every(B.V('activated')),\r\n    function(r10) {\r\n        console.log(r10); // false\r\n    }]);\r\n\r\nC(users, [\r\n    G[\":reject :age > 30\"],\r\n    B.some(B.V('activated')),\r\n    function(r11) {\r\n        console.log(r11); // true\r\n    }]);\r\n```\r\n\r\narray, object, [object, object, object] 등을 편하게 다룰 수 있는 유용한 함수들입니다.\r\n`C.each`, `C.map`, `C.reduce`, `C.filter`, `C.reject`, `C.find`, `C.find_index`, `C.some`, `C.every`, `C.uniq`,\r\n`B.each`, `map`, `B.reduce`, `B.filter`, `B.reject`, `B.find`, `B.find_index`, `B.some`, `B.every`, `B.uniq`\r\n\r\n\r\n\r\n### 08. [HTML Template](https://github.com/marpple/abc-functional-javascript/blob/master/example/08.%20HTML%20Template.html)\r\nabcjs에는 html을 효율적으로 만들 수 있는 template 함수인 `H`, `H.each`, 일반 문자열을 효율적으로 만들 수 있는 `S`, `S.each`가 있습니다.\r\n`H`, `H.each`, `S`, `S.each`는 모두 비동기 제어를 지원하고 abcjs의 다른 함수들과 함께 사용하기 좋습니다.\r\n```javascript\r\nC([\r\n    H('', '\\\r\n        .member[style=\"border: 1px solid #000; padding: 20px;\"]\\\r\n            h3 People\\\r\n            ul\\\r\n                li Cojamm\\\r\n                li BJ\\\r\n                li JM\\\r\n                li PJ\\\r\n                li HA\\\r\n                li JE\\\r\n        #id1.class1.class2[class=class3] hi\\\r\n        .service\\\r\n            a[href=http://www.marpple.com target=_blank] http://www.marpple.com\\\r\n        textarea[rows=10].\\\r\n            Custom T-Shirts\\\r\n            \\\r\n            \\\r\n            Design Platform\\\r\n            Artwork\\\r\n        br\\\r\n/*          br\\\r\n        br*/\\\r\n//            p hi\\\r\n        p hello\\\r\n//            br\\\r\n        textarea\\\r\n            | foo bar\\\r\n            | hello world'),\r\n    $,\r\n    B.M('appendTo', 'body')]);\r\n\r\n\r\nhr();\r\n```\r\n**참고 - 주석은 반드시 맨 앞줄에서 시작되어야합니다.**\r\n\r\n\r\nH-S의 특징\r\n  1. H-S는 js내에서 사용하기위해 만들어졌습니다. 짧게 작성할 수 있게 하기 위해 jade의 문법과 닮았습니다.\r\n  2. jade보다 더욱 css 문법과 동일합니다.\r\n  3. javascript 함수 사용이 편리합니다.\r\n  4. `\"\"`,`''` 등을 생략할 수 있어 문자열을 다루는데 좀더 편리합니다.\r\n  5. handlebars 등의 helper 보다 더욱 편리하게 template을 위한 함수를 만들 수 있습니다.\r\n\r\n\r\n데이터 치환\r\n```javascript\r\nC({ name: 'Cojamm', age: 32 }, [\r\n  H('user', '\\\r\n      .person\\\r\n          .name {{user.name}}\\\r\n          .age {{user.age}}'),\r\n  $,\r\n  B.M('appendTo', 'body')]);\r\n\r\nhr();\r\n\r\nvar post = {\r\n    body: '<em>하이</em> <a href=\"https://www.youtube.com/watch?v=4tdOzlB6I7w\" target=\"_blank\">랩이나 잘하라고</a>',\r\n    name: 'Cojamm',\r\n    created_at: new Date()\r\n};\r\n\r\nC(post, [\r\n    H('post', '\\\r\n        .name 글쓴이: {{post.name}}\\\r\n        .body 내용: {{post.body}}\\\r\n        .created_at 시간: {{post.created_at}}'),\r\n    $,\r\n    B.M('appendTo', 'body')]);\r\n\r\nhr();\r\n\r\ndelete post.name;\r\n\r\nwindow.moment_lll = B([moment, B.M('format', 'lll')]);\r\n\r\nC(post, [\r\n    H('post', '\\\r\n        .name 글쓴이: {{post.name || \"익명\"}}\\\r\n        .body 내용: {{{post.body}}}\\\r\n        .created_at 시간: {{moment_lll(post.created_at)}}'),\r\n    $,\r\n    B.M('appendTo', 'body')]);\r\n\r\nhr();\r\n```\r\n\r\n\r\n`H`의 인자를 여러개를 넘기면 template 문자열을 합치는데 그중 함수를 넣어 함수를 실행 시킬 수 있습니다.\r\n복잡한 로직은 함수로 빼서 구현 할 수 있습니다.\r\n```javascript\r\nvar songs = [\r\n    'The Riddle Of The Model',\r\n    'Up',\r\n    'To Find You',\r\n    'A Beautiful Sea',\r\n    'Drive It Like You Stole It',\r\n    'Up (Bedroom Mix)',\r\n    'Girls',\r\n    'Brown Shoes'];\r\n\r\nC(songs, [\r\n    H('songs', '\\\r\n        h3 Sing Street OST\\\r\n        ul\\\r\n            {{{C(songs, ', function(songs) {\r\n                return _.map(songs, function(song, i) {\r\n                    return '<li>' + (i+1) + '. ' + song + '</li>';\r\n                }).join(\"\");\r\n            },')}}}'),\r\n    $,\r\n    B.M('appendTo', 'body')]);\r\n\r\nhr();\r\n```\r\n위와 같이 익명함수를 선언하여 사용할수도 있습니다. 쉼표가 중요합니다. `{{C(a, ', function() {},')}}`\r\n\r\n`H.each`, `S.each`\r\n```javascript\r\nC(songs, [\r\n    H('songs', '\\\r\n        h3 Sing Street OST\\\r\n        ul\\\r\n            !{C(songs, ', S.each('song, i', '\\\r\n                li {{i+1}}. {{song}}'),\r\n            ')}!'),\r\n    $,\r\n    B.M('appendTo', 'body')]);\r\n\r\n\r\nhr();\r\n```\r\n\r\n\r\n템플릿 동작 순서\r\n  1. `!{}!` 실행 및 데이터 치환, 리턴 값을 H 문법으로 하고 싶을때\r\n  2. H to HTML\r\n  3. `{{{}}}` 실행 및 데이터 치환, 리턴 값을 HTML로 만들고 싶을때\r\n  4. `{{}}` 실행 및 데이터 치환, 리턴 값이 일반 문자열이어야 함\r\n    `!{}!`, `{{}}`, `{{{}}}` 의 실행결과가 `.then` 인 경우 비동기를 기다렸다가 완성합니다.\r\n```javascript\r\nvar sum = CB(function (a, b, cb) {\r\n    delay(function() {\r\n        console.log(a + b);\r\n        cb(a + b);\r\n    });\r\n});\r\n\r\nC(songs, [\r\n    H('songs', '\\\r\n        h3 Sing Street OST\\\r\n        ul\\\r\n            {{{C(songs, ', H.each('song, i', '\\\r\n                li {{C(i, 1, sum)}}. {{song}}'), // delay\r\n            ')}}}'),\r\n    $,\r\n    B.M('appendTo', 'body'), // 2초 뒤 렌더링\r\n    function() {\r\n        $(\"html, body\").animate({ scrollTop: $(window).scrollTop() + $(window).height() });\r\n    }]);\r\n```\r\n\r\n\r\n`S`는 일반 문자열을 만들때 사용합니다. `S`와 `S.each`가 있습니다.\r\n`H`, `H.each`는 HTML로 변환하여 리턴하고 `S`, `S.each`는 데이터 치환만한 문자열을 리턴합니다.\r\n```javascript\r\nC({ id: 5, body: \"foo bar\" }, [\r\n    _.values,\r\n    C.toMR,\r\n    S('id, body', \"update posts set body = '{{body}}' where id = {{id}};\"),\r\n    function(query) {\r\n        console.log(query);\r\n    }]);\r\n```\r\n\r\n\r\n\r\n### 09. [IF ELSEIF ELSE](https://github.com/marpple/abc-functional-javascript/blob/master/example/09.%20IF%20ELSEIF%20ELSE.html)\r\n자바스크립트에서 조건문을 작성할때 함수를 실행할 수 있는데 만일 그 함수가 비동기 함수라면 그렇게 할 수 없고 굉장히 로직이 복잡해지고 코딩하기 어려워집니다.\r\n자바스크립트는 아래와 같이 코딩할 수 없어 이것을 자바스크립트의 단점으로 생각하기도 합니다.\r\n하지만 이것에는 목적이 있습니다. 자바스크립트는 이벤트 루프를 이용하여 Non-Blocking IO을 지원하기 위해 아래 같은 상황에서 비동기가 일어납니다.\r\n\r\n```javascript\r\nif (long_time(1)) {\r\n   long_time(2);\r\n } else if (long_time(3)) {\r\n   long_time(4);\r\n } else {\r\n   long_time(5);\r\n }\r\n```\r\n`long_time()` 함수의 return 값이 undefined 라면 위 코드는 long_time의 내부 구현과 관련 없이 무조건 `long_time(1)`과 `long_time(5)`만 실행될겁니다.\r\n\r\n\r\nabcjs는 비동기가 일어나는 상황에서도 위와 닮은 코딩을 할 수 있도록 `IF().ELSEIF().ELSE()` 를 지원합니다.\r\n\r\n```javascript\r\nIF(\r\n   조건부 함수,\r\n   실행부 함수\r\n)\r\n```\r\n`IF`와 `ELSEIF`는 첫번째 인자로 조건부 함수를 넘기고, 두번째 인자로 실행부 함수를 넘깁니다.\r\n\r\n\r\n```javascript\r\nIF(\r\n   실행부 함수\r\n)\r\n```\r\n만약 위와 같이 실행부 함수만 넘길 경우 내부적으로 조건부 함수를 `function I(v) { return v; }` 로 채웁니다.\r\n\r\n`ELSE`는 실행부 함수만 넘깁니다.\r\n\r\n조건부 함수와 실행부 함수 모두 []로 파이프라인을 만들 수 있습니다.\r\n```javascript\r\nIF([p1, p2, p3], [f1, f2, f3])\r\n```\r\n\r\n`IF().ELSEIF().ELSE()`는 chain 방식으로 function 하나를 리턴합니다. 조건부와 실행부 함수에게 최초 받은 인자들을 넘겨줍니다.\r\n\r\n\r\n```javascript\r\nfunction f1() {\r\n        console.log('f1')\r\n    }\r\n\r\n    function f2() {\r\n        console.log('f2')\r\n    }\r\n\r\n    C(true, IF(f1).ELSE(f2));\r\n    // f1\r\n\r\n    C(false, IF(f1).ELSE(f2));\r\n    // f2\r\n\r\n    C(0,\r\n        IF(f1)\r\n        .ELSEIF(function(v) { return v === 0 },\r\n            function(v) {\r\n                console.log(v);\r\n            })\r\n        .ELSE(f2));\r\n    // 0\r\n\r\n    C(5, 0,\r\n        IF(I, f1 // function I(v) { return v };\r\n        ).ELSEIF(function(a, b) { return a < b },\r\n            function(a, b) { console.log(a); }\r\n        ).ELSE(f2));\r\n    // f1\r\n\r\n    C(0, 5,\r\n        IF(I, f1\r\n        ).ELSEIF(function(a, b) { return a > b },\r\n            function(a, b) { console.log(a); }\r\n        ).ELSE(f2));\r\n    // f2\r\n\r\n    C(0, 5,\r\n        IF(I, f1\r\n        ).ELSEIF(_.negate(function(a, b) { return a > b }),\r\n            function(a, b) { console.log(a+b); }\r\n        ).ELSE(f2));\r\n    // 5\r\n```\r\n\r\n\r\n비동기 조건문\r\n```javascript\r\nG[\"a < b long time\"] = CB(function(a, b, cb) {\r\n    setTimeout(function() {\r\n        console.log('1 sec');\r\n        setTimeout(function() {\r\n            console.log('2 sec');\r\n            cb(a < b);\r\n        }, 1000)\r\n    }, 1000);\r\n});\r\n\r\nC(0, 5,\r\n    IF(I, f1\r\n    ).ELSEIF(G[\"a < b long time\"],\r\n        function(a, b) { console.log(a+b); }\r\n    ).ELSE(f2));\r\n// 5\r\n```\r\n\r\n실행부 역시 비동기제어가 가능하고 배열을 통해 파이프라인으로 만들 수 있습니다.\r\n```javascript\r\nvar square_long_time = CB(function(a, cb) {\r\n    setTimeout(function() {\r\n        cb(a * a);\r\n    }, 1000);\r\n});\r\n\r\nC(0, 5, [\r\n    IF(I, f1\r\n    ).ELSEIF(G[\"a < b long time\"],\r\n        [function(a, b) { return a + b; },\r\n        square_long_time]\r\n    ).ELSE(f2),\r\n    function(a) {\r\n        return a + 10;\r\n    },\r\n    function(r) {\r\n        console.log(r);\r\n        // 35\r\n    }]);\r\n```\r\n\r\n\r\nabcjs를 이용하여 함수형 프로그래밍을 하면 비동기가 지원되는 `IF().ELSEIF().ELSE()` 같은 함수도 아래와 같이 쉽게 만들 수 있습니다.\r\n  1. 최초 `IF`를 실행하면 `store`를 클로저로 생성하고\r\n  2. chain 방식으로 이후에 `ELSEIF`와 `ELSE`가 실행 될때 마다 function set를 `store`에 모아놓고\r\n  3. 리턴된 `IF`가 실행될때 `B.find`를 통해 실행해야하는 function set를 찾아 받아둔 `args`를 넘기며 실행합니다.\r\n\r\n이미 `C`나 `B.find` 등이 이미 비동기를 잘 제어해주기 때문에 아래와 같이 callback 패턴 없이 동기 함수를 만들때와 완전히 똑같은 코딩을 할 수 있습니다.\r\n```javascript\r\n // abc.js 459 line\r\n function IF(predicate, fn) {\r\n     var store = [fn ? [predicate, fn] : [I, predicate]];\r\n     return _.extend(IF, {\r\n         ELSEIF: function (predicate, fn) {\r\n             return store.push(fn ? [predicate, fn] : [I, predicate]) && IF;\r\n         },\r\n         ELSE: function (fn) { return store.push([J(true), fn]) && IF; } });\r\n\r\n     function IF() {\r\n         var args = arguments;\r\n         return C(store, args, [\r\n             B.find(function(fnset, i, l, args) { return A(args, fnset[0]); }),\r\n             function(fnset) { return fnset ? A(args, fnset[1]) : void 0; }\r\n         ]);\r\n     }\r\n }\r\n```\r\n\r\n\r\n\r\n### 10. [B.all B.div](https://github.com/marpple/abc-functional-javascript/blob/master/example/09.%20IF%20ELSEIF%20ELSE.html)\r\n`B.all` 함수는 같은 인자를 모든 파이프라인 혹은 함수에게 넘겨서 multiple results로 결과를 만드는 함수를 리턴합니다.\r\n```javascript\r\nC(1, 5, [\r\n    B.all(\r\n        function(a, b) { return a + b; }, // a\r\n\r\n        [function(a, b) { return a - b; },\r\n        function(a) { return a * a; }],  // b\r\n\r\n        function(a, b) { return MR(a, b); }  // c, d (multiple results)\r\n    ),\r\n    function(a, b, c, d) {\r\n        console.log(a, b, c, d); // 6, 16, 1, 5\r\n    }]);\r\n```\r\n\r\n\r\n`B.div` 함수는 인자를 하나씩 모든 파이프라인 혹은 함수에게 나눠주고 multiple results로 결과를 만드는 함수를 리턴합니다.\r\n```javascript\r\nC(1, 2, 3, 4, [\r\n    B.div(\r\n        function(a) { return a + a; }, // a\r\n\r\n        [function(a) { return a + a; },\r\n        function(a) { return a * a; }], // b\r\n\r\n        function(a) { return MR(a, a - a); }  // c, d (multiple results)\r\n\r\n        // e ** 인자수보다 function의 갯수가 적을 경우 I로 채웁니다. function I(v) { return v }\r\n    ),\r\n    function(a, b, c, d, e) {\r\n        console.log(a, b, c, d, e); // 2, 16, 3, 0, 4\r\n    }]);\r\n\r\nC(1, 2, 3, 4, [\r\n    B.div(\r\n        function(a) { return a + a; }, // a\r\n\r\n        [function(a) { return a + a; },\r\n        function(a) { return a * a; }], // b\r\n\r\n        function(a) { return MR(a, a - a); }, // c, d\r\n\r\n        I, // e\r\n        I  // f  ** 인자수보다 function의 갯수가 많을 경우 인자는 undefined로 들어옵니다.\r\n    ),\r\n    function(a, b, c, d, e, f) {\r\n        console.log(a, b, c, d, e, f); // 2, 16, 3, 0, 4, undefined\r\n    }]);\r\n```\r\n\r\n\r\n결과를 배열로 받고 싶다면\r\n```javascript\r\nC(1, 5, [\r\n    B.all(\r\n        function(a, b) { return a + b; }, // a\r\n\r\n        [function(a, b) { return a - b; },\r\n        function(a) { return a * a; }],  // b\r\n\r\n        function(a, b) { return MR(a, b); }  // c, d (multiple results)\r\n    ),\r\n    C.args,\r\n    C.toArray,\r\n    function(a) {\r\n        console.log(a); // [6, 16, 1, 5]\r\n    }]);\r\n```\r\nPipeline 패턴으로 코딩을 하다보면 `B.all`과 `B.div` 같은 일을 하고 싶을때가 많습니다.\r\n`B.all`과 `B.div`에게 넘겨진 함수 혹은 Pipeline들은 하나씩 차례대로 실행됩니다.\r\n비동기가 일어나더라도 위에서 부터 하나씩 차례대로 실행됩니다.\r\n\r\n### 11. [this](https://github.com/marpple/abc-functional-javascript/blob/master/example/11.%20this.html)\r\nA, B, C 모두 this가 주어진다면 파이프라인안의 모든 함수에서 this를 이어줍니다.\r\n\r\n\r\n#### A 함수로 this 전달하기\r\nA 함수에서는 마지막 인자로 this를 받을 수 있습니다.\r\n```javascript\r\nvar r1 = A([1, 2], [\r\n    function(a, b) {\r\n        return a + b + this.c;\r\n    },\r\n    function(a) {\r\n        return a * this.c;\r\n    }\r\n], { c: 5 });\r\nconsole.log(r1); // 40\r\n````\r\n\r\n\r\n#### B 함수로 this 전달하기\r\nB 함수는 함수를 리턴하는 함수입니다. B를 실행하여 리턴된 함수에 context를 넘겨주셔야합니다.\r\n_.bind나 Function.prototype.bind 처럼 미리 this를 bind하는 기능은 없습니다.\r\n코어 자바스크립트에서의 this를 잘 이해하고 있다면 전혀 어렵지 않습니다.\r\n아래와 같은 케이스가 가능하겠습니다. 메소드 정의를 할때 유용합니다.\r\n```javascript\r\nvar user1 = {\r\n    firstName: \"jamm\",\r\n    lastName: \"Co\",\r\n    getName1: B(function() {\r\n        return this.lastName + ' ' + this.firstName;\r\n    }),\r\n    getName2: B([\r\n        B.all(function() {\r\n            return this.firstName;\r\n        }, function() {\r\n            return this.lastName;\r\n        }),\r\n        function(a, b) {\r\n            return a + ' ' + b;\r\n        }\r\n    ])\r\n};\r\n\r\nconsole.log(user1.getName1()); // Co jamm\r\nconsole.log(user1.getName2()); // jamm Co\r\n\r\nvar same_age_friends = B([\r\n    function() {\r\n        return this.friends;\r\n    },\r\n    B.filter(function(friend) { return friend.age == this.me.age })\r\n]);\r\n\r\nvar r2 = same_age_friends.call({\r\n    friends: [\r\n        { id: 1, name: \"a\", age: 10 },\r\n        { id: 2, name: \"b\", age: 12 },\r\n        { id: 3, name: \"c\", age: 12 },\r\n        { id: 4, name: \"d\", age: 13 }\r\n    ],\r\n    me: { id: 5, name: \"e\", age: 12 }\r\n});\r\n\r\nconsole.log(JSON.stringify(r2)); // [{\"id\":2,\"name\":\"b\",\"age\":12},{\"id\":3,\"name\":\"c\",\"age\":12}]\r\n```\r\n\r\n\r\n#### C 함수로 this 전달하기\r\n```javascript\r\nvar r3 = C.call({ c: 5 }, 1, 2, [\r\n    function(a, b) {\r\n        return a + b + this.c;\r\n    },\r\n    function(a) {\r\n        return a * this.c;\r\n    }\r\n]);\r\nconsole.log(r3); // 40\r\n```\r\n\r\n\r\n#### with jQuery\r\n```html\r\n<button type=\"button\">go</button>\r\n```\r\n```javascript\r\n$(function() {\r\n    $('button').click(B([\r\n        CB(function(e, next) {\r\n            return $(this).animate({\r\n                'margin-left': 300\r\n            }, 1000, next);\r\n        }),\r\n        function() {\r\n            $(this).text('finish');\r\n        }\r\n    ]));\r\n});\r\n// go --------------> finish\r\n```\r\n\r\n\r\n\r\n### 12. ETC\r\n이 외에도 abcjs에는 B.args, B.m, C.val, F, G, C.u, C.val 등의 유용한 함수들이 있습니다.\r\n  - `B.args(n[,n,n...])` index가 n인 인자들 받기\r\n  - `B.m('method', 'args1', 'args2')` 객체의 메소드 실행하는 함수 뱉기\r\n  - `F('function.name') => G['function']['name']` 안전하게 function 찾기\r\n  - `F.A`, `F.B`, `F.C`, ... F 네임스페이스에 모든 함수 재추가\r\n  - `G = global || window`\r\n  - `C.u = function() {};`\r\n  - `C.val(user, 'friend.friends.0.name')` 안전하게 value 꺼내기\r\n\r\n\r\n### 13. [throw, ERR, CATCH](https://github.com/marpple/abc-functional-javascript/blob/master/example/13.%20CATCH.html)\r\n```javascript\r\nC([\r\n    function() {\r\n        console.log(1);\r\n    },\r\n    function() {\r\n        console.log(2);\r\n        throw 2;\r\n    },\r\n    function() {\r\n        console.log(3);\r\n    },\r\n    CATCH(function(e) {\r\n        console.log(4, e);\r\n    })]);\r\n// 1\r\n// 2\r\n// 4, Error: 2(…)\r\nconsole.log('-------------------------');\r\n\r\nC([\r\n    function() {\r\n        console.log(1);\r\n    },\r\n    function() {\r\n        console.log(2);\r\n        return ERR(2);\r\n    },\r\n    function() {\r\n        console.log(3);\r\n    },\r\n    CATCH(function(e) {\r\n        console.log(4, e);\r\n    }),\r\n    function() {\r\n        console.log(5);\r\n    }]);\r\n// 1\r\n// 2\r\n// 4, Error: 2(…)\r\n// 5\r\nconsole.log('-------------------------');\r\n\r\nC([\r\n    function() {\r\n        console.log(1);\r\n        return ERR('custom data', {\r\n            type: 1,\r\n            msg: 'hi'\r\n        });\r\n    },\r\n    CATCH(function(e) {\r\n        if (e.type == 1) {\r\n            console.log(e.msg, e);\r\n        } else {\r\n            console.log('else');\r\n        }\r\n    })]);\r\n// 1\r\n// hi Error: custom data(…)\r\nconsole.log('-------------------------');\r\n\r\nC([\r\n    function() {\r\n        console.log(1);\r\n    },\r\n    function() {\r\n        console.log(2);\r\n    },\r\n    function() {\r\n        console.log(3);\r\n    },\r\n    CATCH(function(e) {\r\n        console.log(4, e);\r\n    }),\r\n    function() {\r\n        console.log(5);\r\n    }]);\r\n\r\n// 1\r\n// 2\r\n// 3\r\n// 5\r\nconsole.log('-------------------------');\r\n\r\nC([\r\n    function() {\r\n        console.log(1);\r\n    },\r\n    function() {\r\n        return C([\r\n            function() {\r\n                console.log(2);\r\n            },\r\n            function() {\r\n                console.log(3);\r\n                throw 3\r\n            },\r\n            function() {\r\n                console.log(4);\r\n            },\r\n            CATCH(function(e) {\r\n                console.log(5, e);\r\n            }),\r\n            function() {\r\n                console.log(6);\r\n            },\r\n            function() {\r\n                console.log(7);\r\n                return ERR(7);\r\n            }\r\n        ])\r\n    },\r\n    function() {\r\n        console.log(8);\r\n    },\r\n    CATCH(function(e) {\r\n        console.log(9, e);\r\n        return 'hi'\r\n    }),\r\n    function(a) {\r\n        console.log(10, a);\r\n    }\r\n]);\r\n// 1\r\n// 2\r\n// 3\r\n// 5 Error: 3(…)\r\n// 6\r\n// 7\r\n// 9 Error: 7(…)\r\n// 10 'hi'\r\n\r\nconsole.log('-------------------------');\r\n\r\n// for async\r\nvar go = B([\r\n    function(a) {\r\n        console.log(1);\r\n        return a;\r\n    },\r\n    CB(function(a, next) {\r\n        console.log(2);\r\n        setTimeout(function() {\r\n            next(a == 1 ? 2 : ERR(2));\r\n        }, 500)\r\n    }),\r\n    function() {\r\n        console.log(3);\r\n    },\r\n    function() {\r\n        console.log(4);\r\n        return 'complete';\r\n    },\r\n    CB(CATCH(function(e, next) {\r\n        console.log(5, e);\r\n        setTimeout(function() {\r\n            // rollback\r\n            next('fail');\r\n        }, 1000);\r\n    })),\r\n    function(a) {\r\n        console.log(a);\r\n        console.log('------------------')\r\n    }\r\n]);\r\n\r\ngo(1).then(function() {\r\n    // 1\r\n    // 2\r\n    // 3\r\n    // 4\r\n    // complete\r\n\r\n    go(2);\r\n    // 1\r\n    // 2\r\n    // 5 Error: 2(…)\r\n    // fail\r\n});\r\n```\r\n\r\n__이제 재밌는 함수 조립을 즐겨보세요! :smile:__\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}